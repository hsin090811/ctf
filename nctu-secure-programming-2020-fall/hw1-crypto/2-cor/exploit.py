#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
from pwn import *
from functools import reduce

output = [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1]


class LFSR:
    def __init__(self, init, feedback):
        self.state = init
        self.feedback = feedback
    def getbit(self):
        nextbit = reduce(lambda x, y: x ^ y, [i & j for i, j in zip(self.state, self.feedback)])
        self.state = self.state[1:] + [nextbit]
        return nextbit


class MixedLFSR:
    def __init__(self, init1, init2, init3):
        self.l1 = LFSR(init1, [int(i) for i in f'{39989:016b}'])
        self.l2 = LFSR(init2, [int(i) for i in f'{40111:016b}'])
        self.l3 = LFSR(init3, [int(i) for i in f'{52453:016b}'])
    def getbit(self):
        x1 = self.l1.getbit()
        x2 = self.l2.getbit()
        x3 = self.l3.getbit()
        return (x1 & x2) ^ ((not x1) & x3)


def get_similarity(bits_list1: list, bits_list2: list) -> int:
    assert len(bits_list1) == len(bits_list2)

    matches = 0.0
    for i in range(len(bits_list1)):
        if bits_list1[i] == bits_list2[i]:
            matches += 1

    return matches / len(bits_list1)


def bruteforce_lfsr(n: int, feedback: int) -> list:
    log.info('bruteforcing lfsr{} ...'.format(n))

    result = []
    for byte1 in range(256):
        for byte2 in range(256):
            init = [int(i) for i in f"{int.from_bytes(bytes([byte1]) + bytes([byte2]), 'big'):016b}"]
            lfsr = LFSR(init, [int(i) for i in f'{feedback:016b}'])
            lfsr_output = [lfsr.getbit() for _ in range(100)]

            if get_similarity(lfsr_output, output) > 0.75:
                log.info('found possible init state: {}'.format(init))
                result.append({'byte1': byte1, 'byte2': byte2, 'bits': init})

    print()  # additional newline for readability
    return result


def main():
    # Bruteforce all possible initial states of lfsr3
    lfsr3_possible_init_states = bruteforce_lfsr(3, 52453)

    # Bruteforce all possible initial states of lfsr2
    lfsr2_possible_init_states = bruteforce_lfsr(2, 40111)

    # Bruteforce all possible initial states of lfsr1
    # using all possible initial states of lfsr3 and lfsr2
    log.info('launching final stage bruteforce attack')
    for byte1 in range(256):
        for byte2 in range(256):
            lfsr1_init = [int(i) for i in f"{int.from_bytes(bytes([byte1]) + bytes([byte2]), 'big'):016b}"]
            mixed_lfsr = MixedLFSR(lfsr1_init,
                                   lfsr2_possible_init_states[0]['bits'],
                                   lfsr3_possible_init_states[0]['bits'])
            mixed_lfsr_output = [mixed_lfsr.getbit() for _ in range(100)]

            if get_similarity(mixed_lfsr_output, output) == 1:
                flag =  'FLAG{'
                flag += '{}{}{}{}{}{}'.format(chr(byte1),
                                              chr(byte2),
                                              chr(lfsr2_possible_init_states[0]['byte1']),
                                              chr(lfsr2_possible_init_states[0]['byte2']),
                                              chr(lfsr3_possible_init_states[0]['byte1']),
                                              chr(lfsr3_possible_init_states[0]['byte2']))
                flag += '}'
                log.info(flag)
                sys.exit(0)


if __name__ == '__main__':
    main()
